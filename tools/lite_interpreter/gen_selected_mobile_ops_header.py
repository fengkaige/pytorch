#!/usr/bin/env python3

import argparse
import os
from typing import Set
from tools.codegen.selective_build.selector import *
from tools.codegen.code_template import CodeTemplate

selected_mobile_ops_preamble = """#pragma once
/**
 * Generated by gen_oplist.py
 */

"""

def extract_root_operators(selective_builder: SelectiveBuilder) -> Set[str]:
    ops = []
    for (op_name, op) in selective_builder.operators.items():
        if op.is_root_operator:
            ops.append(op_name)
    return set(ops)

def get_selected_kernel_dtypes_code(
        selective_builder: SelectiveBuilder,
) -> str:
    # See https://www.internalfb.com/intern/paste/P153411698/ for an example of the
    # generated code in case all kernel dtypes are selected and in case some kernel
    # dtypes are selected (i.e. both cases).
    #
    body = "return true;"
    if selective_builder.include_all_operators is False and selective_builder.include_all_kernel_dtypes is False:
        body_parts = []
        for kernel_tag, dtypes in selective_builder.kernel_metadata.items():
            conditions = list(map(lambda x: 'scalar_type == at::ScalarType::' + x, dtypes))
            body_parts.append(
                if_condition_template.substitute(
                    kernel_tag_name=kernel_tag,
                    dtype_checks=" || ".join(conditions),
                ),
            )
        body = " else ".join(body_parts)

    header_contents = selected_kernel_dtypes_h_template.substitute(body=body)
    return header_contents


# Write the file selected_mobile_ops.h with optionally:
# 1. The selected root operators
# 2. The selected kernel dtypes
#
def write_selected_mobile_ops(
    output_file_path: str,
    root_ops: Set[str],
) -> None:
    with open(output_file_path, "wb") as out_file:
        body_parts = [selected_mobile_ops_preamble]
        body_parts.append("#define TORCH_OPERATOR_WHITELIST " + (";".join(sorted(root_ops))) + ";\n\n")

        header_contents = "".join(body_parts)
        out_file.write(header_contents.encode("utf-8"))

def main():
    parser = argparse.ArgumentParser(description="selected_mobile_ops.h:"
    "Primary operators used by templated selective build and Kernel Function"
    "dtypes captured by tracing ")
    parser.add_argument(
        "-p", "--yaml_file_path", type=str, required=True, help="Path to the yaml"
        " file with a list of operators used by the model."
    )
    parser.add_argument(
        "-o", "--output_file_path", type=str, required=True, help="Path to the yaml"
        " file with a list of operators used by the model."
    )
    parsed_args = parser.parse_args()
    model_file_name = parsed_args.yaml_file_path

    print("Loading yaml file: ", model_file_name)
    loaded_model = {}
    with open(model_file_name, "rb") as model_file:
        loaded_model = yaml.load(model_file)

    root_operators_set = set(loaded_model)
    print("Writing header file selected_mobile_ops.h: ", parsed_args.output_file_path)
    write_selected_mobile_ops(
        os.path.join(parsed_args.output_file_path),
        root_operators_set)


if __name__ == "__main__":
    main()
